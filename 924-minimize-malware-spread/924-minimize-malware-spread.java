class Solution {
    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        // dfs to color rendering the graph
        // find the size of each color
        // for each initial nodes, find the group that has size of 1
        
        // if there is a node in initial group that group size is 1 and its size is the largest one, then it is the result
        // find the smallest node number in the initial, as they are all the same
        
        int n = graph.length;
        
        int[] color = new int[n];
        Arrays.fill(color, -1);
        
        int C = 0;
        
        for (int r = 0; r < n; r++) {
            if (color[r] == -1) {
                dfs(graph, r, color, C);
                C++;
            }
        }
        
        int[] sizeOfColor = new int[C];
        for (int i : color) {
            sizeOfColor[i]++;
        }
        
        int[] colorGroup = new int[C];
        for (int i : initial) {
            colorGroup[color[i]]++;
        }
        
        int res = Integer.MAX_VALUE;
        int maxSeen = 0;
        for (int i : initial) {
            // make sure unique group
            if (colorGroup[color[i]] == 1) {
                if (sizeOfColor[color[i]] > maxSeen) {
                    maxSeen = sizeOfColor[color[i]];
                    res = i;
                } else if (sizeOfColor[color[i]] == maxSeen && i < res) {
                    res = i;
                }
            }
        }
        
        if (res == Integer.MAX_VALUE) {
            for (int i : initial) {
                res = Math.min(res, i);
            }
        }
        
        return res;
    }
    
    
    private void dfs(int[][] graph, int r, int[] color, int C) {
        color[r] = C;
        
        for (int c = 0; c < graph[r].length; c++) {
            if (r == c) continue;
            if (graph[r][c] == 1 && color[c] == -1) {
                dfs(graph, c, color, C);
            }
        }
    }
    
    // Union Find
    /*
    class UnionFind {
        int[] parent;
        int[] size;
        
        public UnionFind(int n) {
            this.parent = new int[n];
            this.size = new int[n];
            
            for (int i = 0; i < n; i++) {
                this.parent[i] = i;
                this.size[i] = 1;
            }
        }
        
        public int find(int i) {
            if (this.parent[i] == i) {
                return i;
            }
            
            this.parent[i] = this.find(this.parent[i]);
            return this.parent[i];
        }
        
        public void union(int a, int b) {
            int aP = this.find(a);
            int bP = this.find(b);
            
            if (aP != bP) {
                if (this.size[aP] > this.size[bP]) {
                    this.parent[bP] = aP;
                    this.size[aP] += this.size[bP];
                } else {
                    this.parent[aP] = bP;
                    this.size[bP] += this.size[aP];
                }
            }
        }
        
        public int getSize(int i) {
            return this.size[i];
        }
    }
    
    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        
        UnionFind uf = new UnionFind(n);
        
        for (int r = 0; r < n; r++)
            for (int c = 0; c < n; c++) {
                if (r == c) continue;
                if (graph[r][c] == 1) {
                    uf.union(r, c);
                }
            }
        
        int[] colorGroupCnt = new int[n];
        // 如果有两个或以上，那么说明remove其中一个color没有意义，因为会被后面color再染上
        // 只有当colorGroupCnt是 1 的时候，说明是独立的group，那么只需要找到最大的group size即可
        for (int i : initial) {
            colorGroupCnt[uf.find(i)]++;
        }
        
        int res = -1, maxSize = -1;
        // 这里要loop initial里的node，千万不要loop所有的0 ~ (n - 1)的nodes
        for (int node : initial) {
            int root = uf.find(node);
            if (colorGroupCnt[root] == 1) {
                int rootSize = uf.getSize(root);
                if (res == -1) {
                    res = node;
                    maxSize = uf.getSize(root);
                } else if (rootSize > maxSize) {
                    res = node;
                    maxSize = rootSize;
                } else if (rootSize == maxSize && node < res) {
                    res = node;
                }
            }
        }
        
        if (res == -1) {
            res = Integer.MAX_VALUE;
            for (int i : initial) {
                res = Math.min(res, i);
            }
        }
        
        return res;
    }
    */

    
    /* Option 1 - Color Rendering + DFS
    public int minMalwareSpread(int[][] graph, int[] initial) {
        // undirected graph
        // from a single source, how many nodes can be reached
        int n = graph.length;
        
        int C = 0;
        int[] colors = new int[n];
        Arrays.fill(colors, -1);
        
        for (int i = 0; i < n; i++) {
            if (colors[i] == -1) {
                this.dfs(i, graph, colors, C);
                C++;
            }
        }
        
        int[] size = new int[C];
        for (int color : colors) {
            size[color]++;
        }
        
        int[] initColorCnt = new int[C];
        for (int node : initial) {
            initColorCnt[colors[node]]++;
        }
        
        int res = Integer.MAX_VALUE;
        for (int node : initial) {
            int c = colors[node];
            // unique color
            // if two initial nodes have the same color, removing one won't minimize malware
            // below is to find the largest size of unique color
            if (initColorCnt[c] == 1) {
                if (res == Integer.MAX_VALUE) {
                    res = node;
                } else if (size[c] > size[colors[res]]) {
                    res = node;
                } else if (size[c] == size[colors[res]] && node < res) {
                    res = node;
                } 
            }
        }
        
        if (res == Integer.MAX_VALUE) {
            for (int node : initial) {
                res = Math.min(res, node);
            }
        }
        
        return res;
    }
    
    private void dfs(int node, int[][] graph, int[] colors, int C) {
        colors[node] = C;
        for (int next = 0; next < graph.length; next++) {
            // not visited
            if (graph[node][next] == 1 && colors[next] == -1) {
                this.dfs(next, graph, colors, C);
            }
        }
    }
    */
}